%%%-------------------------------------------------------------------
-module(ocibuild_sign).
-moduledoc """
Cosign-compatible image signing using ECDSA P-256.

Implements the cosign simplesigning v1 format for container image signatures.
Signatures are pushed as OCI artifacts via the referrers API.

## Key Format

Supports PEM-encoded ECDSA P-256 private keys (cosign default):

```bash
# Generate with cosign
cosign generate-key-pair

# Or with openssl
openssl ecparam -genkey -name prime256v1 -noout -out cosign.key
```

## Usage

```erlang
{ok, PrivateKey} = ocibuild_sign:load_key("/path/to/cosign.key"),
{ok, PayloadJson, Signature} = ocibuild_sign:sign(ManifestDigest, DockerRef, PrivateKey).
```

## Verification

After pushing the signature, verify with cosign:

```bash
cosign verify --key cosign.pub ghcr.io/myorg/myapp:latest
```
""".

-export([
    load_key/1,
    sign/3,
    build_payload/2,
    build_signature_manifest/3,
    build_referrer_manifest/5,
    artifact_type/0
]).

-include_lib("public_key/include/public_key.hrl").

%%%===================================================================
%%% Types
%%%===================================================================

-type private_key() :: #'ECPrivateKey'{}.

-type sign_payload() :: #{
    binary() => #{
        binary() => binary() | #{binary() => binary()}
    }
}.

-export_type([private_key/0, sign_payload/0]).

%% OID for secp256r1 (P-256) curve: 1.2.840.10045.3.1.7
-define(SECP256R1_OID, {1, 2, 840, 10045, 3, 1, 7}).

%%%===================================================================
%%% Public API
%%%===================================================================

-doc """
Get the artifact type for cosign signatures.

Returns the cosign simplesigning v1 media type used as the artifact type
in OCI referrer manifests.
""".
-spec artifact_type() -> binary().
artifact_type() ->
    ~"application/vnd.dev.cosign.simplesigning.v1+json".

-doc """
Load an ECDSA P-256 private key from a PEM file.

Supports PEM-encoded EC private keys as generated by cosign or openssl.
The key must use the P-256 (secp256r1/prime256v1) curve.

Returns `{ok, PrivateKey}` on success, or `{error, Reason}` on failure.

Example:
```erlang
{ok, Key} = ocibuild_sign:load_key("cosign.key").
```
""".
-spec load_key(Path :: file:filename()) -> {ok, private_key()} | {error, term()}.
load_key(Path) ->
    case file:read_file(Path) of
        {ok, PemBin} ->
            decode_pem_key(PemBin);
        {error, Reason} ->
            {error, {key_read_failed, Path, Reason}}
    end.

-doc """
Build the cosign simplesigning payload.

Creates the JSON payload that will be signed. The payload contains:
- `critical.identity.docker-reference`: The full image reference
- `critical.image.docker-manifest-digest`: The manifest digest being signed
- `critical.type`: Always "cosign container image signature"
- `optional`: Empty map (reserved for future extensions)

Example:
```erlang
Payload = ocibuild_sign:build_payload(
    ~"sha256:abc123...",
    ~"ghcr.io/myorg/myapp:v1"
).
```
""".
-spec build_payload(ManifestDigest :: binary(), DockerRef :: binary()) -> sign_payload().
build_payload(ManifestDigest, DockerRef) ->
    #{
        ~"critical" => #{
            ~"identity" => #{~"docker-reference" => DockerRef},
            ~"image" => #{~"docker-manifest-digest" => ManifestDigest},
            ~"type" => ~"cosign container image signature"
        },
        ~"optional" => #{}
    }.

-doc """
Sign a manifest digest and return the payload and signature.

Builds the simplesigning payload, encodes it as JSON, and signs it with
the ECDSA P-256 private key using SHA-256.

Returns `{ok, PayloadJson, Signature}` where:
- `PayloadJson` is the JSON-encoded payload (binary)
- `Signature` is the DER-encoded ECDSA signature (binary)

Example:
```erlang
{ok, Key} = ocibuild_sign:load_key("cosign.key"),
{ok, PayloadJson, Signature} = ocibuild_sign:sign(
    ~"sha256:abc123...",
    ~"ghcr.io/myorg/myapp:v1",
    Key
).
```
""".
-spec sign(ManifestDigest :: binary(), DockerRef :: binary(), PrivateKey :: private_key()) ->
    {ok, PayloadJson :: binary(), Signature :: binary()}.
sign(ManifestDigest, DockerRef, PrivateKey) ->
    Payload = build_payload(ManifestDigest, DockerRef),
    PayloadJson = ocibuild_json:encode(Payload),
    Signature = public_key:sign(PayloadJson, sha256, PrivateKey),
    {ok, PayloadJson, Signature}.

-doc """
Build a cosign signature manifest for tag-based discovery.

Creates a manifest that cosign will find at the signature tag (sha256-<digest>.sig).
This is the default discovery mechanism used by cosign verify.

The manifest structure follows the cosign simplesigning format:
- Config blob contains the simplesigning payload
- Layer references the same payload with signature in annotation

Note: Unlike `build_referrer_manifest/5`, this does NOT include a `subject` field
since tag-based discovery doesn't use the OCI referrers API.

Parameters:
- `PayloadDigest`: SHA256 digest of the payload JSON
- `PayloadSize`: Size of the payload JSON in bytes
- `Signature`: The DER-encoded ECDSA signature

Example:
```erlang
Manifest = ocibuild_sign:build_signature_manifest(PayloadDigest, PayloadSize, Signature).
```
""".
-spec build_signature_manifest(
    PayloadDigest :: binary(),
    PayloadSize :: non_neg_integer(),
    Signature :: binary()
) -> map().
build_signature_manifest(PayloadDigest, PayloadSize, Signature) ->
    %% Signature is base64-encoded in the layer annotation
    SignatureB64 = base64:encode(Signature),
    ArtifactType = artifact_type(),

    #{
        ~"schemaVersion" => 2,
        ~"mediaType" => ~"application/vnd.oci.image.manifest.v1+json",
        ~"config" => #{
            ~"mediaType" => ArtifactType,
            ~"digest" => PayloadDigest,
            ~"size" => PayloadSize
        },
        ~"layers" => [
            #{
                ~"mediaType" => ArtifactType,
                ~"digest" => PayloadDigest,
                ~"size" => PayloadSize,
                ~"annotations" => #{
                    ~"dev.cosignproject.cosign/signature" => SignatureB64
                }
            }
        ]
    }.

-doc """
Build an OCI referrer manifest for a cosign signature.

Creates a manifest following the OCI referrers API specification that
attaches a signature to a subject image manifest. The manifest structure
follows the cosign simplesigning format:

- Config blob contains the simplesigning payload
- Layer references the same payload with signature in annotation
- Subject points to the signed image manifest

Parameters:
- `PayloadDigest`: SHA256 digest of the payload JSON
- `PayloadSize`: Size of the payload JSON in bytes
- `Signature`: The DER-encoded ECDSA signature
- `SubjectDigest`: SHA256 digest of the image manifest being signed
- `SubjectSize`: Size of the image manifest in bytes

Example:
```erlang
Manifest = ocibuild_sign:build_referrer_manifest(
    PayloadDigest, PayloadSize, Signature, SubjectDigest, SubjectSize
).
```
""".
-spec build_referrer_manifest(
    PayloadDigest :: binary(),
    PayloadSize :: non_neg_integer(),
    Signature :: binary(),
    SubjectDigest :: binary(),
    SubjectSize :: non_neg_integer()
) -> map().
build_referrer_manifest(PayloadDigest, PayloadSize, Signature, SubjectDigest, SubjectSize) ->
    %% Signature is base64-encoded in the layer annotation
    SignatureB64 = base64:encode(Signature),
    ArtifactType = artifact_type(),

    #{
        ~"schemaVersion" => 2,
        ~"mediaType" => ~"application/vnd.oci.image.manifest.v1+json",
        ~"artifactType" => ArtifactType,
        ~"config" => #{
            ~"mediaType" => ArtifactType,
            ~"digest" => PayloadDigest,
            ~"size" => PayloadSize
        },
        ~"layers" => [
            #{
                ~"mediaType" => ArtifactType,
                ~"digest" => PayloadDigest,
                ~"size" => PayloadSize,
                ~"annotations" => #{
                    ~"dev.cosignproject.cosign/signature" => SignatureB64
                }
            }
        ],
        ~"subject" => #{
            ~"mediaType" => ~"application/vnd.oci.image.manifest.v1+json",
            ~"digest" => SubjectDigest,
            ~"size" => SubjectSize
        },
        ~"annotations" => #{
            ~"org.opencontainers.image.created" => ocibuild_time:get_iso8601()
        }
    }.

%%%===================================================================
%%% Internal functions
%%%===================================================================

%% @private Decode a PEM-encoded private key
-spec decode_pem_key(binary()) -> {ok, private_key()} | {error, term()}.
decode_pem_key(PemBin) ->
    try
        case public_key:pem_decode(PemBin) of
            [] ->
                {error, {invalid_pem, no_entries}};
            [PemEntry | _] ->
                decode_pem_entry(PemEntry)
        end
    catch
        _:Reason ->
            {error, {pem_decode_failed, Reason}}
    end.

%% @private Decode a single PEM entry
-spec decode_pem_entry(public_key:pem_entry()) -> {ok, private_key()} | {error, term()}.
decode_pem_entry(PemEntry) ->
    try
        Key = public_key:pem_entry_decode(PemEntry),
        validate_ecdsa_p256(Key)
    catch
        _:Reason ->
            {error, {key_decode_failed, Reason}}
    end.

%% @private Validate that the key is ECDSA P-256
-spec validate_ecdsa_p256(term()) -> {ok, private_key()} | {error, term()}.
validate_ecdsa_p256(#'ECPrivateKey'{parameters = {namedCurve, Oid}} = Key) ->
    case Oid of
        ?SECP256R1_OID ->
            {ok, Key};
        _ ->
            {error, {unsupported_curve, Oid, expected_secp256r1}}
    end;
validate_ecdsa_p256(#'ECPrivateKey'{parameters = Params}) ->
    {error, {unsupported_curve_format, Params}};
validate_ecdsa_p256(Key) when is_tuple(Key) ->
    {error, {not_ec_key, element(1, Key)}};
validate_ecdsa_p256(Key) ->
    {error, {invalid_key_format, Key}}.
